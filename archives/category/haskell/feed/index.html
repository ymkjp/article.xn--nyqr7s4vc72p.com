<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Haskell &#8211; It works!</title>
	<atom:link href="https://xn--nyqr7s4vc72p.com/archives/category/haskell/feed" rel="self" type="application/rss+xml" />
	<link>https://xn--nyqr7s4vc72p.com</link>
	<description>A techie blog</description>
	<lastBuildDate>Wed, 07 Sep 2016 17:42:50 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.6.1</generator>

<image>
	<url>https://xn--nyqr7s4vc72p.com/wp-content/uploads/2016/03/identicon.png</url>
	<title>Haskell &#8211; It works!</title>
	<link>https://xn--nyqr7s4vc72p.com</link>
	<width>32</width>
	<height>32</height>
</image> 
<site xmlns="com-wordpress:feed-additions:1">108279505</site>	<item>
		<title>【順次追記中】すごいH本 珠玉の名言集</title>
		<link>https://xn--nyqr7s4vc72p.com/archives/64</link>
		<comments>https://xn--nyqr7s4vc72p.com/archives/64#respond</comments>
		<pubDate>Sun, 23 Mar 2014 07:28:00 +0000</pubDate>
		<dc:creator><![CDATA[@i05]]></dc:creator>
				<category><![CDATA[dev]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[書評]]></category>

		<guid isPermaLink="false">http://tk2-249-34500.vs.sakura.ne.jp/2014/03/23/%e3%80%90%e9%a0%86%e6%ac%a1%e8%bf%bd%e8%a8%98%e4%b8%ad%e3%80%91%e3%81%99%e3%81%94%e3%81%84h%e6%9c%ac-%e7%8f%a0%e7%8e%89%e3%81%ae%e5%90%8d%e8%a8%80%e9%9b%86/</guid>
		<description><![CDATA[Lipovaca, Miran 著『すごいHaskellたのしく学ぼう！』を読んでいます。 いわゆる『すごいH本』というやつですね。 この本を読んでいるあいだはおもしろすぎで脳汁プッシャーヘブン状態なわけですが、気に入った一文をメモしているうちに珠玉の名言集ができていることに気がついたので紹介していきます。 ではまず1番「すごい」と思った名言から。 Best Word of Wisdom Haskellでは再帰が重要です。なぜなら、 Haskellでは命令型言語のように計算をどうやってするかを指定するのではなく、 求めるものが何であるかを宣言して計算を行うからです。Haskellの目的は、 計算を実行するステップをコンピュータに示すことではなく、 欲しい結果が何であるかを直接定義することであり、 そのために再帰的な方法をよく使うのです。 これぞ珠玉。 「計算を実行するステップをコンピュータに示すことではなく、 欲しい結果が何であるかを直接定義する」。僕がプログラミングを初める前にもっていたプログラミングのイメージってそんな感じでした。 後日、小島寛之さんのエッセイ『世界を読みとく数学入門』を読んでいて気づいたのですが、この「ほしい結果が何であるかを直接定義する」という恩恵は非常に強力で、数式を眺めるていると「ふむ、Haskellに落としこむならこうかな」という類推が簡単にできちゃうのです。 「巨人の肩に乗る」ことにかけて数式をコードに翻訳してしまうことほど手っ取り早いことはないでしょう。ただそれを使いこなせるかどうかは別ですけどね ;) Favorite way of programming 「基本的で、 明らかに正しい関数を組み合わせて、 より大きな関数を組み立てる」 これはうなずいてしまう人も多いのではないでしょうか。 僕は他の手続き型言語を書いている時もできるだけ細かな処理ごとに関数に切り分けていくほうが「好き」なので、この文化はかなりしっくりきました。 余談ですが初心者向けに「同じ処理を2回書いたら関数にまとめましょう」と言われることもありますが、あの言い方はよくないと思うんですよねー (方便だとはわかりつつも)。 Not statement, it&#8217;s expression Haskellのifは必ず値を返す式であって、 文ではないのです。 これは Haskell の if 式がかならず else をつけなければならない理由として述べられていました。 手続き型で書いている時もできるだけ if else で書き分けたほうがいいよなぁと漠然と思っていたのですが、言語仕様にまで落とし込まれているのを知って驚きと嬉しさがありました。 Well-polished naming Stringは、 [Char]の単なる別名です。 型クラス周りのエレガントさ。この命名にも萌えました。 &#8230; <a href="https://xn--nyqr7s4vc72p.com/archives/64" class="more-link">Continue reading<span class="screen-reader-text"> "【順次追記中】すごいH本 珠玉の名言集"</span></a>]]></description>
				<content:encoded><![CDATA[<p>Lipovaca, Miran 著『<a href="http://www.amazon.co.jp/gp/product/B009RO80XY/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B009RO80XY&amp;linkCode=as2&amp;tag=m0b55-22">すごいHaskellたのしく学ぼう！</a>』を読んでいます。</p>
<p>いわゆる『すごいH本』というやつですね。</p>
<p><a href="http://www.amazon.co.jp/gp/product/B009RO80XY/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B009RO80XY&amp;linkCode=as2&amp;tag=m0b55-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=B009RO80XY&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=m0b55-22" /></a></p>
<p>この本を読んでいるあいだはおもしろすぎで脳汁プッシャーヘブン状態なわけですが、気に入った一文をメモしているうちに珠玉の名言集ができていることに気がついたので紹介していきます。</p>
<p>ではまず1番「すごい」と思った名言から。</p>
<h4><b>Best Word of Wisdom</b></h4>
<p>
<blockquote>Haskellでは再帰が重要です。なぜなら、 Haskellでは命令型言語のように計算をどうやってするかを指定するのではなく、 求めるものが何であるかを宣言して計算を行うからです。Haskellの目的は、 計算を実行するステップをコンピュータに示すことではなく、 欲しい結果が何であるかを直接定義することであり、 そのために再帰的な方法をよく使うのです。</p></blockquote>
<p>これぞ珠玉。</p>
<p>「計算を実行するステップをコンピュータに示すことではなく、 欲しい結果が何であるかを直接定義する」。僕がプログラミングを初める前にもっていたプログラミングのイメージってそんな感じでした。</p>
<p>後日、小島寛之さんのエッセイ『<a href="http://www.amazon.co.jp/gp/product/B00FSAHLTK/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B00FSAHLTK&amp;linkCode=as2&amp;tag=m0b55-22">世界を読みとく数学入門</a>』を読んでいて気づいたのですが、この「ほしい結果が何であるかを直接定義する」という恩恵は非常に強力で、数式を眺めるていると「ふむ、Haskellに落としこむならこうかな」という類推が簡単にできちゃうのです。</p>
<p>「巨人の肩に乗る」ことにかけて数式をコードに翻訳してしまうことほど手っ取り早いことはないでしょう。ただそれを使いこなせるかどうかは別ですけどね ;)</p>
<h4><b><br />Favorite way of programming</b></h4>
<p>
<blockquote>「基本的で、 明らかに正しい関数を組み合わせて、 より大きな関数を組み立てる」</p></blockquote>
<p>これはうなずいてしまう人も多いのではないでしょうか。</p>
<p>僕は他の手続き型言語を書いている時もできるだけ細かな処理ごとに関数に切り分けていくほうが「好き」なので、この文化はかなりしっくりきました。</p>
<p>余談ですが初心者向けに「同じ処理を2回書いたら関数にまとめましょう」と言われることもありますが、あの言い方はよくないと思うんですよねー (方便だとはわかりつつも)。</p>
<h4><b><br />Not statement, it&#8217;s expression</b></h4>
<p>
<blockquote>Haskellのifは必ず値を返す式であって、 文ではないのです。</p></blockquote>
<p>これは Haskell の if 式がかならず else をつけなければならない理由として述べられていました。</p>
<p>手続き型で書いている時もできるだけ if else で書き分けたほうがいいよなぁと漠然と思っていたのですが、言語仕様にまで落とし込まれているのを知って驚きと嬉しさがありました。</p>
<h4><b><br />Well-polished naming</b></h4>
<p>
<blockquote>Stringは、 [Char]の単なる別名です。</p></blockquote>
<p>型クラス周りのエレガントさ。この命名にも萌えました。</p>
<p><code>ghci&gt; :t 'a'<br />'a' :: Char<br />ghci&gt; :t "a"<br />"a" :: [Char]</code></p>
<h4><b><br />Amazing infinite list</b></h4>
<p>
<blockquote>次のように無限リストを使うほうが良い方法です</p></blockquote>
<p>無限リストは、もうあれですね。「うおー、遅延評価強えぇ！」感。</p>
<p>感動のあまり <a href="http://ymkjp.blogspot.jp/2014/03/fizzbuzz-in-haskell.html">気づいたら FizzBuzz 書いてた</a>。入門書読んでてこんなに FizzBuzz が書きたくなったのははじめて。</p>
<h4><b><br />Feels safe without effort</b></h4>
<p>
<blockquote>「ヘイ、 分からないなら教えてあげるけど、 この式はこの型なんだよ！ 」</p></blockquote>
<p>型注釈について。</p>
<p>基本は Haskell に任せて、必要なときにだけ教えてあげるっていう設計思想は静的型付の堅牢さとのバランスがすばらしい。</p>
<p><code>ghci&gt; (read "5" :: Float) * 4<br />20.0</code></p>
<h4><b><br />What a beautiful expression</b></h4>
<p><code>fn x = ceiling (negate (tan (cos (max 50 x))))</code> が <code>fn = ceiling . negate . tan . cos . max 50</code> と書けることについて。</p>
<p>
<blockquote>素ん晴らしい！ ポイントフリースタイルにすると読みやすく簡潔になることが多々あります。 データよりも関数に目がいくようになり、 どのようにデータが移り変わっていくかではなく、 どんな関数を合成して何になっているかを考えやすくなるからです。 <br />単純な関数から始め、 関数合成を糊として使うことにより、 より複雑な関数を作り出せばよいのです。</p></blockquote>
<p>確かにすんばらしい！ こういうプログラミングの書きたさ、読みやすさ、楽しさみたいなのを提供してくれるのはとてもよいです。</p>
<p>ラムダを簡潔に書けたり、カッコを減らせたり、そういう部分がサポートされているのはすんばらしい  (関数合成と関数適用演算子)。</p>
<p>関数合成はいじくっているうちに、だんだんメソッドチェーンに見えてきました。適用の向きが逆ですが、楽しさはいっしょです :)</p>
<h4><b><br />Good joke</b></h4>
<p>
<blockquote>再帰が何なのかまだよく分からないなら、 この段落をもう一度読んでください。<br />（冗談ですよ！ ）</p></blockquote>
<p>再帰的ジョーク。笑ったのはもう1個次のやつも。</p>
<p>
<blockquote>は思いっきり目を細めるとギリシャ文字のラムダλに見えますよね。</p></blockquote>
<p>無理矢理感ｗ</p>
<p>無理矢理感といえばこちらも。</p>
<p>
<blockquote>あなたが通りを歩いていると、 老婦人が近づいてきて言いました。 「すみません。 各桁の数の合計が40になる最初の自然数は何でしょうか？ 」</p></blockquote>
<p>老婦人ｗ</p>
<h4><b>Tips: How to write <code>where</code>&#8216;s Indent</b></h4>
<p>最後に名言とは関係ないのですが、すごいH本を読んでいてハマったところが1箇所だけあったのでその回避方法を。</p>
<p><code>where</code> はインデントをそろえないとコンパイルエラーを起こすのですが、その規則が分かりにくいので次の例のように改行して定義してしまったほうがよさそうです。</p>
<p>※ サンプルのインデントが大きくなっちゃってるのは space 2 にしてもなぜか gist が勝手に tab 8 にしてくれるから&#8230;orz</p>
<div><adress><a href="http://twitter.com/ymkjp">@ymkjp</a></adress></div>
]]></content:encoded>
			<wfw:commentRss>https://xn--nyqr7s4vc72p.com/archives/64/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">64</post-id>	</item>
		<item>
		<title>無限リストを使った FizzBuzz in Haskell</title>
		<link>https://xn--nyqr7s4vc72p.com/archives/65</link>
		<comments>https://xn--nyqr7s4vc72p.com/archives/65#respond</comments>
		<pubDate>Sun, 23 Mar 2014 07:04:00 +0000</pubDate>
		<dc:creator><![CDATA[@i05]]></dc:creator>
				<category><![CDATA[dev]]></category>
		<category><![CDATA[Haskell]]></category>
		<category><![CDATA[書評]]></category>

		<guid isPermaLink="false">http://tk2-249-34500.vs.sakura.ne.jp/2014/03/23/%e7%84%a1%e9%99%90%e3%83%aa%e3%82%b9%e3%83%88%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%9f-fizzbuzz-in-haskell/</guid>
		<description><![CDATA[こんなに FizzBuzz 書きたくなった入門書ははじめてだよ！ take 100 [ if x `mod` 15 == 0 then "FizzBuzz" else if x `mod` 5 == 0 then "Buzz" else if x `mod` 3 == 0 then "Fizz" else show x &#124; x]]></description>
				<content:encoded><![CDATA[<p>こんなに FizzBuzz 書きたくなった入門書ははじめてだよ！</p>
<p><a href="http://www.amazon.co.jp/gp/product/B009RO80XY/ref=as_li_ss_il?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=B009RO80XY&amp;linkCode=as2&amp;tag=m0b55-22"><img border="0" src="http://ws-fe.amazon-adsystem.com/widgets/q?_encoding=UTF8&amp;ASIN=B009RO80XY&amp;Format=_SL160_&amp;ID=AsinImage&amp;MarketPlace=JP&amp;ServiceVersion=20070822&amp;WS=1&amp;tag=m0b55-22" /></a></p>
<p><code>take 100 [<br />    if x `mod` 15 == 0 then "FizzBuzz"<br />    else if x `mod` 5 == 0 then "Buzz"<br />    else if x `mod` 3 == 0 then "Fizz"<br />    else show x | x <- [1..] ]</code></p>
<p>ということで100までの FizzBuzz を書いてみた。</p>
<p><a href="https://gist.github.com/ymkjp/9686839">https://gist.github.com/ymkjp/9686839</a></p>
<div><adress><a href="http://twitter.com/ymkjp">@ymkjp</a></adress></div>
]]></content:encoded>
			<wfw:commentRss>https://xn--nyqr7s4vc72p.com/archives/65/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
	<post-id xmlns="com-wordpress:feed-additions:1">65</post-id>	</item>
	</channel>
</rss>
